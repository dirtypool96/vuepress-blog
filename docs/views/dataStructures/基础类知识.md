---
title: 时间复杂度 & 空间复杂度
date: 2020-05-05
sidebar: "auto"
categories:
  - 数据结构
tags:
  - 数据结构
---

::: tip

时间复杂度和空间复杂度详解

:::

<!-- more -->
## 一、时间复杂度

> ### 推导大O阶方法
>
> 1、用**常数1**取代运行时间中的所有加法常数。
>
> 2、在修改后的运行次数函数中，**只保留最高阶项**。
>
> 3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。

### 1）常数阶

```C
int sum = 0, n = 100; /*执行一次*/
sum = (1 + n) * n / 2; /*执行一次*/
printf("%d",sum); /*执行一次*/
```

这个算法的运行次数函数是f (n) =3，根据我们推导大0阶的方法，第一步就是把常数项3 改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为**O(1)**。

### 2）线性阶

```c
int i;
for(i = 0; i < n; i++){
	/*时间复杂度为O(1)的程序步骤序列*/
}
```

循环的代码执行n次，循环的时间复杂度为**O(n)**

### 3）对数阶

```C
int count = 1;
while (count < n){
	count = count * 2;
    /*时间复杂度为O(1)的程序步骤序列*/
}
```

由于每次count乘以2之后，就距离n更近了一分。 也就是说，有多少个2相乘后大于n，则会退出循环。 由2^x=n 得到x=logn。 所以这个循环的时间复杂度为**O(logn)**。

### 4）平方阶

```c
int i, j;
for(i = 0; i < n; i++){
　　for(j = 0; j < n; j++){
		/*时间复杂度为O(1)的程序步骤序列*/
　　}
}
```

**O(n^2)**

### 5）循环嵌套

```c
int i, j;
for(i = 0; i < n; i++){
　　for(j = i; j < n; j++){ /*注意j = i而不是0*/
　　	/*时间复杂度为O(1)的程序步骤序列*/
　　}
}
```

由于当i=0时，内循环执行了n次，当i = 1时，执行了n-1次，……当i=n-1时，执行了1次。所以总的执行次数为:

n + (n-1) + (n-2) + ....+ 1 = n^2/2 + n/2

用我们推导大O阶的方法

1、没有加法常数不予考虑；

2、只保留最高阶项，因此保留时(n^2)/2;

3、去除这个项相乘的常数，也就是去除1/2

最终这段代码的时间复杂度为**O(n^2)**。

### 6）最坏情况和平均情况

>  我们查找一个有n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。
>   **最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。 在应用中，这是一种最重要的需求， 通常， 除非特别指定， 我们提到的运行时间都是最坏情况的运行时间。**
>   而平均运行时间也就是从概率的角度看， 这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2次后发现这个目标元素。**平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。**也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。一般在没有特殊说明的情况下，都是指**最坏时间复杂度**。

## 二、空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势。

### 1）空间复杂度 **O(1)**

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：

```text
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

### 2）空间复杂度 **O(n)**

我们先看一个代码：

```text
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

### 3）空间复杂度**O(n^2)**

```
const matrix = [];
for (let i = 0; i < nl i++) {
	matrix.push([]);
	for (let j = 0; j < n;j++) {
		matrix[i].push(j)
	}
}
```

二维数组的情况下，存储了n^2个变量。

